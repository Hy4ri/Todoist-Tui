func (a *App) View() string {
	if a.width == 0 {
		return "Loading..."
	}

	var content string
	switch a.currentView {
	case ViewHelp:
		content = a.helpComp.View()
	case ViewTaskDetail:
		content = a.renderTaskDetail()
	case ViewTaskForm:
		content = a.renderTaskForm()
	case ViewSearch:
		content = a.renderSearch()
	case ViewCalendarDay:
		content = a.renderCalendarDay()
	case ViewSections:
		content = a.renderSections()
	default:
		content = a.renderMainView()
	}

	// Overlay project creation dialog if active
	if a.isCreatingProject {
		dialogWidth := 50
		dialogStyle := lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(styles.Highlight).
			Padding(1, 2).
			Width(dialogWidth)

		dialogContent := styles.Title.Render("üìÅ New Project") + "\n\n" +
			a.projectInput.View() + "\n\n" +
			styles.HelpDesc.Render("Enter: create ‚Ä¢ Esc: cancel")

		dialog := dialogStyle.Render(dialogContent)

		// Center the dialog
		dialogLines := strings.Split(dialog, "\n")
		centeredDialog := ""
		leftPad := (a.width - dialogWidth - 4) / 2
		if leftPad < 0 {
			leftPad = 0
		}
		for _, line := range dialogLines {
			centeredDialog += strings.Repeat(" ", leftPad) + line + "\n"
		}

		// Overlay on content
		contentLines := strings.Split(content, "\n")
		dialogLineCount := len(dialogLines)
		startLine := (len(contentLines) - dialogLineCount) / 2
		if startLine < 0 {
			startLine = 0
		}

		// Replace content lines with dialog
		dialogSplit := strings.Split(centeredDialog, "\n")
		for i := 0; i < len(dialogSplit) && startLine+i < len(contentLines); i++ {
			contentLines[startLine+i] = dialogSplit[i]
		}
		content = strings.Join(contentLines, "\n")
	}

	// Overlay active overlays...
	// (Skipping project/label overlays replication for brevity... waiting for replace_file_content to handle context correctly)
	// I should probably target specific blocks instead of replcaing huge chunks unless necessary.
	// But I will append section overlays at the END of overlays list.

	// Overlay project edit dialog if active
	if a.isEditingProject {
		dialogWidth := 50
		dialogStyle := lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(styles.Highlight).
			Padding(1, 2).
			Width(dialogWidth)

		dialogContent := styles.Title.Render("‚úèÔ∏è Edit Project") + "\n\n" +
			a.projectInput.View() + "\n\n" +
			styles.HelpDesc.Render("Enter: save ‚Ä¢ Esc: cancel")

		dialog := dialogStyle.Render(dialogContent)

		// Center the dialog
		dialogLines := strings.Split(dialog, "\n")
		centeredDialog := ""
		leftPad := (a.width - dialogWidth - 4) / 2
		if leftPad < 0 {
			leftPad = 0
		}
		for _, line := range dialogLines {
			centeredDialog += strings.Repeat(" ", leftPad) + line + "\n"
		}

		// Overlay on content
		contentLines := strings.Split(content, "\n")
		dialogLineCount := len(dialogLines)
		startLine := (len(contentLines) - dialogLineCount) / 2
		if startLine < 0 {
			startLine = 0
		}

		// Replace content lines with dialog
		dialogSplit := strings.Split(centeredDialog, "\n")
		for i := 0; i < len(dialogSplit) && startLine+i < len(contentLines); i++ {
			contentLines[startLine+i] = dialogSplit[i]
		}
		content = strings.Join(contentLines, "\n")
	}

	// Overlay project delete confirmation dialog if active
	if a.confirmDeleteProject && a.editingProject != nil {
		dialogWidth := 50
		dialogStyle := lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(styles.ErrorColor).
			Padding(1, 2).
			Width(dialogWidth)

		dialogContent := styles.StatusBarError.Render("‚ö†Ô∏è Delete Project?") + "\n\n" +
			fmt.Sprintf("Are you sure you want to delete \"%s\"?\n", a.editingProject.Name) +
			styles.HelpDesc.Render("This will delete all tasks in this project.") + "\n\n" +
			styles.HelpDesc.Render("y: confirm ‚Ä¢ n/Esc: cancel")

		dialog := dialogStyle.Render(dialogContent)

		// Center the dialog
		dialogLines := strings.Split(dialog, "\n")
		centeredDialog := ""
		leftPad := (a.width - dialogWidth - 4) / 2
		if leftPad < 0 {
			leftPad = 0
		}
		for _, line := range dialogLines {
			centeredDialog += strings.Repeat(" ", leftPad) + line + "\n"
		}

		// Overlay on content
		contentLines := strings.Split(content, "\n")
		dialogLineCount := len(dialogLines)
		startLine := (len(contentLines) - dialogLineCount) / 2
		if startLine < 0 {
			startLine = 0
		}

		// Replace content lines with dialog
		dialogSplit := strings.Split(centeredDialog, "\n")
		for i := 0; i < len(dialogSplit) && startLine+i < len(contentLines); i++ {
			contentLines[startLine+i] = dialogSplit[i]
		}
		content = strings.Join(contentLines, "\n")
	}

	// Overlay label creation dialog if active
	if a.isCreatingLabel {
		dialogWidth := 50
		dialogStyle := lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(styles.Highlight).
			Padding(1, 2).
			Width(dialogWidth)

		dialogContent := styles.Title.Render("üè∑Ô∏è New Label") + "\n\n" +
			a.labelInput.View() + "\n\n" +
			styles.HelpDesc.Render("Enter: create ‚Ä¢ Esc: cancel")

		dialog := dialogStyle.Render(dialogContent)

		// Center the dialog
		dialogLines := strings.Split(dialog, "\n")
		centeredDialog := ""
		leftPad := (a.width - dialogWidth - 4) / 2
		if leftPad < 0 {
			leftPad = 0
		}
		for _, line := range dialogLines {
			centeredDialog += strings.Repeat(" ", leftPad) + line + "\n"
		}

		// Overlay on content
		contentLines := strings.Split(content, "\n")
		dialogLineCount := len(dialogLines)
		startLine := (len(contentLines) - dialogLineCount) / 2
		if startLine < 0 {
			startLine = 0
		}

		// Replace content lines with dialog
		dialogSplit := strings.Split(centeredDialog, "\n")
		for i := 0; i < len(dialogSplit) && startLine+i < len(contentLines); i++ {
			contentLines[startLine+i] = dialogSplit[i]
		}
		content = strings.Join(contentLines, "\n")
	}

	// Overlay label edit dialog if active
	if a.isEditingLabel {
		dialogWidth := 50
		dialogStyle := lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(styles.Highlight).
			Padding(1, 2).
			Width(dialogWidth)

		dialogContent := styles.Title.Render("‚úèÔ∏è Edit Label") + "\n\n" +
			a.labelInput.View() + "\n\n" +
			styles.HelpDesc.Render("Enter: save ‚Ä¢ Esc: cancel")

		dialog := dialogStyle.Render(dialogContent)

		// Center the dialog
		dialogLines := strings.Split(dialog, "\n")
		centeredDialog := ""
		leftPad := (a.width - dialogWidth - 4) / 2
		if leftPad < 0 {
			leftPad = 0
		}
		for _, line := range dialogLines {
			centeredDialog += strings.Repeat(" ", leftPad) + line + "\n"
		}

		// Overlay on content
		contentLines := strings.Split(content, "\n")
		dialogLineCount := len(dialogLines)
		startLine := (len(contentLines) - dialogLineCount) / 2
		if startLine < 0 {
			startLine = 0
		}

		// Replace content lines with dialog
		dialogSplit := strings.Split(centeredDialog, "\n")
		for i := 0; i < len(dialogSplit) && startLine+i < len(contentLines); i++ {
			contentLines[startLine+i] = dialogSplit[i]
		}
		content = strings.Join(contentLines, "\n")
	}

	// Overlay label delete confirmation dialog if active
	if a.confirmDeleteLabel && a.editingLabel != nil {
		dialogWidth := 50
		dialogStyle := lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(styles.ErrorColor).
			Padding(1, 2).
			Width(dialogWidth)

		dialogContent := styles.StatusBarError.Render("‚ö†Ô∏è Delete Label?") + "\n\n" +
			fmt.Sprintf("Are you sure you want to delete \"%s\"?\n", a.editingLabel.Name) +
			styles.HelpDesc.Render("y: confirm ‚Ä¢ n/Esc: cancel")

		dialog := dialogStyle.Render(dialogContent)

		// Center the dialog
		dialogLines := strings.Split(dialog, "\n")
		centeredDialog := ""
		leftPad := (a.width - dialogWidth - 4) / 2
		if leftPad < 0 {
			leftPad = 0
		}
		for _, line := range dialogLines {
			centeredDialog += strings.Repeat(" ", leftPad) + line + "\n"
		}

		// Overlay on content
		contentLines := strings.Split(content, "\n")
		dialogLineCount := len(dialogLines)
		startLine := (len(contentLines) - dialogLineCount) / 2
		if startLine < 0 {
			startLine = 0
		}

		// Replace content lines with dialog
		dialogSplit := strings.Split(centeredDialog, "\n")
		for i := 0; i < len(dialogSplit) && startLine+i < len(contentLines); i++ {
			contentLines[startLine+i] = dialogSplit[i]
		}
		content = strings.Join(contentLines, "\n")
	}

	// Overlay subtask creation dialog if active
	if a.isCreatingSubtask {
		dialogWidth := 60
		dialogStyle := lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(styles.Highlight).
			Padding(1, 2).
			Width(dialogWidth)

		dialogContent := styles.Title.Render("‚ûï Add Subtask") + "\n\n" +
			a.subtaskInput.View() + "\n\n" +
			styles.HelpDesc.Render("Enter: create ‚Ä¢ Esc: cancel")

		dialog := dialogStyle.Render(dialogContent)

		// Center the dialog
		dialogLines := strings.Split(dialog, "\n")
		centeredDialog := ""
		leftPad := (a.width - dialogWidth - 4) / 2
		if leftPad < 0 {
			leftPad = 0
		}
		for _, line := range dialogLines {
			centeredDialog += strings.Repeat(" ", leftPad) + line + "\n"
		}

		// Overlay on content
		contentLines := strings.Split(content, "\n")
		dialogLineCount := len(dialogLines)
		startLine := (len(contentLines) - dialogLineCount) / 2
		if startLine < 0 {
			startLine = 0
		}

		// Replace content lines with dialog
		dialogSplit := strings.Split(centeredDialog, "\n")
		for i := 0; i < len(dialogSplit) && startLine+i < len(contentLines); i++ {
			contentLines[startLine+i] = dialogSplit[i]
		}
		content = strings.Join(contentLines, "\n")
	}

	// Overlay section creation dialog if active
	if a.isCreatingSection {
		dialogWidth := 50
		dialogStyle := lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(styles.Highlight).
			Padding(1, 2).
			Width(dialogWidth)

		dialogContent := styles.Title.Render("üìÇ New Section") + "\n\n" +
			a.sectionInput.View() + "\n\n" +
			styles.HelpDesc.Render("Enter: create ‚Ä¢ Esc: cancel")

		dialog := dialogStyle.Render(dialogContent)

		// Center the dialog
		dialogLines := strings.Split(dialog, "\n")
		centeredDialog := ""
		leftPad := (a.width - dialogWidth - 4) / 2
		if leftPad < 0 {
			leftPad = 0
		}
		for _, line := range dialogLines {
			centeredDialog += strings.Repeat(" ", leftPad) + line + "\n"
		}

		// Overlay on content
		contentLines := strings.Split(content, "\n")
		dialogLineCount := len(dialogLines)
		startLine := (len(contentLines) - dialogLineCount) / 2
		if startLine < 0 {
			startLine = 0
		}

		// Replace content lines with dialog
		dialogSplit := strings.Split(centeredDialog, "\n")
		for i := 0; i < len(dialogSplit) && startLine+i < len(contentLines); i++ {
			contentLines[startLine+i] = dialogSplit[i]
		}
		content = strings.Join(contentLines, "\n")
	}

	// Overlay section edit dialog if active
	if a.isEditingSection {
		dialogWidth := 50
		dialogStyle := lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(styles.Highlight).
			Padding(1, 2).
			Width(dialogWidth)

		dialogContent := styles.Title.Render("‚úèÔ∏è Edit Section") + "\n\n" +
			a.sectionInput.View() + "\n\n" +
			styles.HelpDesc.Render("Enter: save ‚Ä¢ Esc: cancel")

		dialog := dialogStyle.Render(dialogContent)

		// Center the dialog
		dialogLines := strings.Split(dialog, "\n")
		centeredDialog := ""
		leftPad := (a.width - dialogWidth - 4) / 2
		if leftPad < 0 {
			leftPad = 0
		}
		for _, line := range dialogLines {
			centeredDialog += strings.Repeat(" ", leftPad) + line + "\n"
		}

		// Overlay on content
		contentLines := strings.Split(content, "\n")
		dialogLineCount := len(dialogLines)
		startLine := (len(contentLines) - dialogLineCount) / 2
		if startLine < 0 {
			startLine = 0
		}

		// Replace content lines with dialog
		dialogSplit := strings.Split(centeredDialog, "\n")
		for i := 0; i < len(dialogSplit) && startLine+i < len(contentLines); i++ {
			contentLines[startLine+i] = dialogSplit[i]
		}
		content = strings.Join(contentLines, "\n")
	}

	// Overlay section delete confirmation dialog if active
	if a.confirmDeleteSection && a.editingSection != nil {
		dialogWidth := 50
		dialogStyle := lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(styles.ErrorColor).
			Padding(1, 2).
			Width(dialogWidth)

		dialogContent := styles.StatusBarError.Render("‚ö†Ô∏è Delete Section?") + "\n\n" +
			fmt.Sprintf("Are you sure you want to delete \"%s\"?\n", a.editingSection.Name) +
			styles.HelpDesc.Render("This will likely delete/move tasks inside.") + "\n\n" +
			styles.HelpDesc.Render("y: confirm ‚Ä¢ n/Esc: cancel")

		dialog := dialogStyle.Render(dialogContent)

		// Center the dialog
		dialogLines := strings.Split(dialog, "\n")
		centeredDialog := ""
		leftPad := (a.width - dialogWidth - 4) / 2
		if leftPad < 0 {
			leftPad = 0
		}
		for _, line := range dialogLines {
			centeredDialog += strings.Repeat(" ", leftPad) + line + "\n"
		}

		// Overlay on content
		contentLines := strings.Split(content, "\n")
		dialogLineCount := len(dialogLines)
		startLine := (len(contentLines) - dialogLineCount) / 2
		if startLine < 0 {
			startLine = 0
		}

		// Replace content lines with dialog
		dialogSplit := strings.Split(centeredDialog, "\n")
		for i := 0; i < len(dialogSplit) && startLine+i < len(contentLines); i++ {
			contentLines[startLine+i] = dialogSplit[i]
		}
		content = strings.Join(contentLines, "\n")
		content = strings.Join(contentLines, "\n")
	}

	// Overlay move task dialog if active
	if a.isMovingTask {
		dialogWidth := 50
		dialogStyle := lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(styles.Highlight).
			Padding(1, 2).
			Width(dialogWidth)

		var b strings.Builder
		b.WriteString(styles.Title.Render("‚û°Ô∏è Move Task to Section") + "\n\n")

		if len(a.sections) == 0 {
			b.WriteString(styles.HelpDesc.Render("No sections in this project."))
		} else {
			for i, section := range a.sections {
				cursor := "  "
				style := lipgloss.NewStyle()
				if i == a.moveSectionCursor {
					cursor = "> "
					style = lipgloss.NewStyle().Foreground(styles.Highlight)
				}
				b.WriteString(cursor + style.Render(section.Name) + "\n")
			}
		}

		b.WriteString("\n" + styles.HelpDesc.Render("j/k: select ‚Ä¢ Enter: move ‚Ä¢ Esc: cancel"))

		dialog := dialogStyle.Render(b.String())

		// Center the dialog
		dialogLines := strings.Split(dialog, "\n")
		centeredDialog := ""
		leftPad := (a.width - dialogWidth - 4) / 2
		if leftPad < 0 {
			leftPad = 0
		}
		for _, line := range dialogLines {
			centeredDialog += strings.Repeat(" ", leftPad) + line + "\n"
		}

		// Overlay on content
		contentLines := strings.Split(content, "\n")
		dialogLineCount := len(dialogLines)
		startLine := (len(contentLines) - dialogLineCount) / 2
		if startLine < 0 {
			startLine = 0
		}

		// Replace content lines with dialog
		dialogSplit := strings.Split(centeredDialog, "\n")
		for i := 0; i < len(dialogSplit) && startLine+i < len(contentLines); i++ {
			contentLines[startLine+i] = dialogSplit[i]
		}
		content = strings.Join(contentLines, "\n")
	}

	// Overlay add comment dialog if active
	if a.isAddingComment {
		dialogWidth := 60
		dialogStyle := lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(styles.Highlight).
			Padding(1, 2).
			Width(dialogWidth)

		dialogContent := styles.Title.Render("üí¨ Add Comment") + "\n\n" +
			a.commentInput.View() + "\n\n" +
			styles.HelpDesc.Render("Enter: submit ‚Ä¢ Esc: cancel")

		dialog := dialogStyle.Render(dialogContent)

		// Center the dialog
		dialogLines := strings.Split(dialog, "\n")
		centeredDialog := ""
		leftPad := (a.width - dialogWidth - 4) / 2
		if leftPad < 0 {
			leftPad = 0
		}
		for _, line := range dialogLines {
			centeredDialog += strings.Repeat(" ", leftPad) + line + "\n"
		}

		// Overlay on content
		contentLines := strings.Split(content, "\n")
		dialogLineCount := len(dialogLines)
		startLine := (len(contentLines) - dialogLineCount) / 2
		if startLine < 0 {
			startLine = 0
		}

		// Replace content lines with dialog
		dialogSplit := strings.Split(centeredDialog, "\n")
		for i := 0; i < len(dialogSplit) && startLine+i < len(contentLines); i++ {
			contentLines[startLine+i] = dialogSplit[i]
		}
		content = strings.Join(contentLines, "\n")
	}

	return content
}

// renderMainView renders the main layout with tab bar and content.
func (a *App) renderMainView() string {
	// Render tab bar
	tabBar := a.renderTabBar()

	// Calculate content height dynamically (total - tab bar - status bar)
	tabBarHeight := lipgloss.Height(tabBar)
	statusBarHeight := 2
	contentHeight := a.height - tabBarHeight - statusBarHeight

	var mainContent string

	// If detail panel is shown, split the view
	if a.showDetailPanel && a.selectedTask != nil {
		// Split layout
		detailWidth := a.width / 2
		remainingWidth := a.width - detailWidth - 3 // -3 for border/spacing

		if a.currentTab == TabProjects {
			// Three-pane layout: Sidebar | Tasks | Detail
			sidebarWidth := 30
			if remainingWidth < 70 {
				sidebarWidth = 20
			}
			if remainingWidth < 50 {
				sidebarWidth = 15
			}

			// We need 2 spaces for joins
			taskListWidth := remainingWidth - sidebarWidth - 2

			// Sizing validation
			if taskListWidth < 20 {
				taskListWidth = 20
			}

			// Render Sidebar
			a.sidebarComp.SetSize(sidebarWidth, contentHeight)
			a.sidebarComp.SetCursor(a.sidebarCursor)
			if a.focusedPane == PaneSidebar {
				a.sidebarComp.Focus()
			} else {
				a.sidebarComp.Blur()
			}
			if a.currentProject != nil {
				a.sidebarComp.SetActiveProject(a.currentProject.ID)
			}
			sidebarPane := a.sidebarComp.View()

			// Render Task List
			taskListPane := a.renderProjectTaskList(taskListWidth, contentHeight)

			// Render Detail
			a.detailComp.SetSize(detailWidth, contentHeight)
			a.detailComp.SetTask(a.selectedTask)
			a.detailComp.SetComments(a.comments)
			if a.currentView == ViewTaskDetail {
				a.detailComp.Focus()
			} else {
				a.detailComp.Blur()
			}
			rightPane := a.detailComp.ViewPanel()

			// Enforce strict dimensions for top alignment and stable layout
			sidebarPane = lipgloss.Place(sidebarWidth, contentHeight, lipgloss.Left, lipgloss.Top, sidebarPane)
			taskListPane = lipgloss.Place(taskListWidth, contentHeight, lipgloss.Left, lipgloss.Top, taskListPane)
			rightPane = lipgloss.Place(detailWidth, contentHeight, lipgloss.Left, lipgloss.Top, rightPane)

			mainContent = lipgloss.JoinHorizontal(lipgloss.Top, sidebarPane, " ", taskListPane, " ", rightPane)
		} else {
			// Two-pane layout: Tasks | Detail
			// Need 1 space for join
			listWidth := remainingWidth - 1
			leftPane := a.renderTaskList(listWidth, contentHeight)

			// Render Detail
			a.detailComp.SetSize(detailWidth, contentHeight)
			a.detailComp.SetTask(a.selectedTask)
			a.detailComp.SetComments(a.comments)
			if a.currentView == ViewTaskDetail {
				a.detailComp.Focus()
			} else {
				a.detailComp.Blur()
			}
			rightPane := a.detailComp.ViewPanel()

			// Enforce strict dimensions
			leftPane = lipgloss.Place(listWidth, contentHeight, lipgloss.Left, lipgloss.Top, leftPane)
			rightPane = lipgloss.Place(detailWidth, contentHeight, lipgloss.Left, lipgloss.Top, rightPane)

			mainContent = lipgloss.JoinHorizontal(lipgloss.Top, leftPane, " ", rightPane)
		}

	} else {
		if a.currentTab == TabProjects {
			// Projects tab shows sidebar + content
			mainContent = a.renderProjectsTabContent(a.width, contentHeight)
		} else {
			// Other tabs show content only (full width)
			mainContent = a.renderTaskList(a.width-2, contentHeight)
		}
	}

	// Add status bar
	statusBar := a.renderStatusBar()

	return lipgloss.JoinVertical(lipgloss.Left, tabBar, mainContent, statusBar)
}

// renderDetailPanel renders task details in the right panel for split view.
func (a *App) renderDetailPanel(width, height int) string {
	if a.selectedTask == nil {
		return ""
	}

	t := a.selectedTask

	// Create border style
	panelStyle := lipgloss.NewStyle().
		BorderStyle(lipgloss.RoundedBorder()).
		BorderForeground(styles.Highlight).
		Padding(0, 1).
		Width(width - 2).
		Height(height - 2)

	// Build content
	var content strings.Builder

	// Title - use Width to ensure Lipgloss handles wrapping and style continuation
	content.WriteString(styles.Title.Width(width-6).Render(t.Content) + "\n\n")

	// Due date
	if t.Due != nil {
		content.WriteString(styles.StatusBarKey.Render("Due: "))
		content.WriteString(t.Due.String + "\n")
	}

	// Priority
	priorityStyle := styles.GetPriorityStyle(t.Priority)
	priorityLabel := fmt.Sprintf("P%d", 5-t.Priority)
	content.WriteString(styles.StatusBarKey.Render("Priority: "))
	content.WriteString(priorityStyle.Render(priorityLabel) + "\n")

	// Description
	if t.Description != "" {
		content.WriteString("\n" + styles.StatusBarKey.Render("Description:") + "\n")
		content.WriteString(t.Description + "\n")
	}

	// Comments
	if len(a.comments) > 0 {
		content.WriteString("\n" + styles.StatusBarKey.Render(fmt.Sprintf("Comments (%d):", len(a.comments))) + "\n")
		for _, c := range a.comments {
			content.WriteString("‚Ä¢ " + c.Content + "\n")
		}
	}

	// Help
	content.WriteString("\n" + styles.HelpDesc.Render("Esc to close"))

	return panelStyle.Render(content.String())
}

// tabInfo holds tab metadata for rendering and click handling.
type tabInfo struct {
	tab       Tab
	icon      string
	name      string
	shortName string
}

// getTabDefinitions returns the tab definitions.
func getTabDefinitions() []tabInfo {
	return []tabInfo{
		{TabToday, "[T]", "Today", "Tdy"},
		{TabUpcoming, "[U]", "Upcoming", "Up"},
		{TabLabels, "[L]", "Labels", "Lbl"},
		{TabCalendar, "[C]", "Calendar", "Cal"},
		{TabProjects, "[P]", "Projects", "Prj"},
	}
}

// renderTabBar renders the top tab bar.
func (a *App) renderTabBar() string {
	tabs := getTabDefinitions()

	// Determine label style based on available width
	// Full: "T Today" (~9 chars rendered), Short: "T Tdy" (~7 chars), Minimal: "T" (~3 chars)
	// Each tab with padding(2+2) + separator(1) = +5 chars overhead
	// 5 tabs * 14 chars (full with padding) = ~70 chars minimum for full labels
	useShortLabels := a.width < 80
	useMinimalLabels := a.width < 50

	var tabStrs []string
	for _, t := range tabs {
		var label string
		if useMinimalLabels {
			label = t.icon
		} else if useShortLabels {
			label = fmt.Sprintf("%s %s", t.icon, t.shortName)
		} else {
			label = fmt.Sprintf("%s %s", t.icon, t.name)
		}

		if a.currentTab == t.tab {
			tabStrs = append(tabStrs, styles.TabActive.Render(label))
		} else {
			tabStrs = append(tabStrs, styles.Tab.Render(label))
		}
	}

	tabLine := strings.Join(tabStrs, " ")

	// Truncate if still too wide
	maxWidth := a.width - 4 // Account for TabBar padding
	if lipgloss.Width(tabLine) > maxWidth && maxWidth > 0 {
		tabLine = lipgloss.NewStyle().MaxWidth(maxWidth).Render(tabLine)
	}

	return styles.TabBar.Width(a.width).Render(tabLine)
}

// renderProjectsTabContent renders content for the Projects tab (sidebar + tasks).
func (a *App) renderProjectsTabContent(width, height int) string {
	sidebarWidth := 30 // Wider sidebar for full project names
	if width < 70 {
		sidebarWidth = 20
	}
	if width < 50 {
		sidebarWidth = 15
	}
	mainWidth := width - sidebarWidth - 4
	if mainWidth < 20 {
		mainWidth = 20
	}

	// Render sidebar (project list) - using component
	a.sidebarComp.SetSize(sidebarWidth, height)
	a.sidebarComp.SetItems(a.sidebarItems)
	a.sidebarComp.SetCursor(a.sidebarCursor) // Sync cursor from App state
	if a.focusedPane == PaneSidebar {
		a.sidebarComp.Focus()
	} else {
		a.sidebarComp.Blur()
	}
	if a.currentProject != nil {
		a.sidebarComp.SetActiveProject(a.currentProject.ID)
	}
	sidebar := a.sidebarComp.View()

	// Render main content (tasks for selected project)
	main := a.renderProjectTaskList(mainWidth, height)

	// Enforce strict dimensions
	sidebar = lipgloss.Place(sidebarWidth, height, lipgloss.Left, lipgloss.Top, sidebar)
	main = lipgloss.Place(mainWidth, height, lipgloss.Left, lipgloss.Top, main)

	return lipgloss.JoinHorizontal(lipgloss.Top, sidebar, " ", main)
}

// renderProjectTaskList renders the task list for the selected project.
func (a *App) renderProjectTaskList(width, height int) string {
	var content string

	// Reserve space for borders (top + bottom = 2 lines)
	innerHeight := height - 2
	if innerHeight < 5 {
		innerHeight = 5
	}

	// Calculate inner width for the content
	innerWidth := width - styles.MainContent.GetHorizontalFrameSize()

	if a.currentProject == nil {
		content = styles.HelpDesc.Render("Select a project from the sidebar")
	} else {
		content = a.renderDefaultTaskList(innerWidth, innerHeight)
	}

	containerStyle := styles.MainContent
	if a.focusedPane == PaneMain {
		containerStyle = styles.MainContentFocused
	}

	return containerStyle.Width(width).Height(innerHeight).Render(content)
}

// renderTaskList renders the task list for Today/Upcoming/Labels views.
func (a *App) renderTaskList(width, height int) string {
	// Calculate viewport height (subtract title and padding)
	innerHeight := height - 2
	if innerHeight < 5 {
		innerHeight = 5
	}

	// Calculate inner width for the content
	innerWidth := width - styles.MainContent.GetHorizontalFrameSize()

	var content string
	switch a.currentView {
	case ViewUpcoming:
		content = a.renderUpcoming(innerWidth, innerHeight)
	case ViewLabels:
		content = a.renderLabelsView(innerWidth, innerHeight)
	case ViewCalendar:
		content = a.renderCalendar(innerHeight) // Calendar handles own sizing
	default:
		content = a.renderDefaultTaskList(innerWidth, innerHeight)
	}

	// Apply container style with fixed height
	containerStyle := styles.MainContent
	if a.focusedPane == PaneMain {
		containerStyle = styles.MainContentFocused
	}

	return containerStyle.Width(width).Height(innerHeight).Render(content)
}

// renderDefaultTaskList renders the default task list for Today/Project views.
func (a *App) renderDefaultTaskList(width, maxHeight int) string {
	var b strings.Builder

	// Title
	var title string
	switch a.currentView {
	case ViewToday:
		title = time.Now().Format("Monday 2 Jan")
	case ViewProject:
		if a.currentProject != nil {
			title = a.currentProject.Name
		}
	default:
		title = "Tasks"
	}
	b.WriteString(styles.Title.Render(title))
	b.WriteString("\n\n")

	if a.loading {
		b.WriteString(a.spinner.View())
		b.WriteString(" Loading...")
	} else if a.err != nil {
		b.WriteString(styles.StatusBarError.Render(fmt.Sprintf("Error: %v", a.err)))
	} else if len(a.tasks) == 0 {
		msg := "No tasks found"
		if a.currentView == ViewToday {
			msg = "All done for today! \n" + styles.HelpDesc.Render("Enjoy your day off üèùÔ∏è")
		} else {
			msg = "No tasks here.\n" + styles.HelpDesc.Render("Press 'a' to add one.")
		}
		b.WriteString(msg)
	} else {
		// Group tasks by due status for Today view
		// Title uses 2 lines (title + newline)
		if a.currentView == ViewToday {
			b.WriteString(a.renderGroupedTasks(width, maxHeight-2))
		} else if a.currentView == ViewProject {
			b.WriteString(a.renderProjectTasks(width, maxHeight-2))
		} else {
			b.WriteString(a.renderFlatTasks(width, maxHeight-2))
		}
	}

	return b.String()
}

// lineInfo represents a display line with optional task reference.
type lineInfo struct {
	content   string
	taskIndex int    // -1 for headers
	sectionID string // section ID if this is a section header
}

// renderProjectTasks renders tasks grouped by section for a project.
func (a *App) renderProjectTasks(width, maxHeight int) string {
	// Build ordered list of task indices matching display order
	var orderedIndices []int

	// Group tasks by section
	tasksBySection := make(map[string][]int)
	var noSectionTasks []int

	for i, t := range a.tasks {
		if t.SectionID != nil && *t.SectionID != "" {
			tasksBySection[*t.SectionID] = append(tasksBySection[*t.SectionID], i)
		} else {
			noSectionTasks = append(noSectionTasks, i)
		}
	}

	var lines []lineInfo

	// 1. First, tasks without sections
	if len(noSectionTasks) > 0 {
		for _, i := range noSectionTasks {
			orderedIndices = append(orderedIndices, i)
			lines = append(lines, lineInfo{content: a.renderTaskByDisplayIndex(i, orderedIndices, width), taskIndex: i})
		}
		// Add spacer if there are sections following
		if len(a.sections) > 0 {
			lines = append(lines, lineInfo{content: "", taskIndex: -1})
		}
	}

	// 2. Then, tasks by section (in order)
	if len(a.sections) > 0 {
		for _, section := range a.sections {
			taskIndices := tasksBySection[section.ID]

			// Create section header index (unique negative value)
			headerIndex := -100 - len(orderedIndices)
			orderedIndices = append(orderedIndices, headerIndex)

			if len(taskIndices) == 0 {
				lines = append(lines, lineInfo{
					content:   a.renderSectionHeaderByIndex(section.Name, headerIndex, orderedIndices),
					taskIndex: headerIndex,
					sectionID: section.ID,
				})
			} else {
				lines = append(lines, lineInfo{
					content:   a.renderSectionHeaderByIndex(section.Name, headerIndex, orderedIndices),
					taskIndex: headerIndex,
					sectionID: section.ID,
				})
				for _, i := range taskIndices {
					orderedIndices = append(orderedIndices, i)
					lines = append(lines, lineInfo{content: a.renderTaskByDisplayIndex(i, orderedIndices, width), taskIndex: i})
				}
			}
			// Add blank line after section for spacing
			lines = append(lines, lineInfo{content: "", taskIndex: -1})
		}
	}

	return a.renderScrollableLines(lines, orderedIndices, maxHeight)
}

// renderGroupedTasks renders tasks grouped by due status.
func (a *App) renderGroupedTasks(width, maxHeight int) string {
	var overdue, today, other []int

	// Group tasks
	for i, t := range a.tasks {
		if t.IsOverdue() {
			overdue = append(overdue, i)
		} else if t.IsDueToday() {
			today = append(today, i)
		} else {
			other = append(other, i)
		}
	}

	// Build ordered indices
	var orderedIndices []int
	orderedIndices = append(orderedIndices, overdue...)
	orderedIndices = append(orderedIndices, today...)
	orderedIndices = append(orderedIndices, other...)

	// Build lines
	var lines []lineInfo

	if len(overdue) > 0 {
		lines = append(lines, lineInfo{content: styles.SectionHeader.Render("OVERDUE"), taskIndex: -1})
		for _, i := range overdue {
			lines = append(lines, lineInfo{content: a.renderTaskByDisplayIndex(i, orderedIndices, width), taskIndex: i})
		}
	}

	if len(today) > 0 {
		if len(overdue) > 0 {
			lines = append(lines, lineInfo{content: "", taskIndex: -1})
		}
		for _, i := range today {
			lines = append(lines, lineInfo{content: a.renderTaskByDisplayIndex(i, orderedIndices, width), taskIndex: i})
		}
	}

	if len(other) > 0 {
		if len(overdue) > 0 || len(today) > 0 {
			lines = append(lines, lineInfo{content: "", taskIndex: -1})
		}
		lines = append(lines, lineInfo{content: styles.SectionHeader.Render("NO DUE DATE"), taskIndex: -1})
		for _, i := range other {
			lines = append(lines, lineInfo{content: a.renderTaskByDisplayIndex(i, orderedIndices, width), taskIndex: i})
		}
	}

	return a.renderScrollableLines(lines, orderedIndices, maxHeight)
}

// renderFlatTasks renders tasks in a flat list.
func (a *App) renderFlatTasks(width, maxHeight int) string {
	var lines []lineInfo
	var orderedIndices []int

	for i := range a.tasks {
		orderedIndices = append(orderedIndices, i)
		lines = append(lines, lineInfo{content: a.renderTaskByDisplayIndex(i, orderedIndices, width), taskIndex: i})
	}

	return a.renderScrollableLines(lines, orderedIndices, maxHeight)
}

// renderSectionHeaderByIndex renders a section header with cursor highlighting for empty sections.
func (a *App) renderSectionHeaderByIndex(sectionName string, headerIndex int, orderedIndices []int) string {
	// Find display position for cursor
	displayPos := 0
	for i, idx := range orderedIndices {
		if idx == headerIndex {
			displayPos = i
			break
		}
	}

	// Check if cursor is on this empty section header
	isCursorHere := displayPos == a.taskCursor && a.focusedPane == PaneMain

	// Cursor indicator
	cursor := "  "
	if isCursorHere {
		cursor = "> "
	}

	// Truncate section name to prevent wrapping
	// Available width = App Width - Sidebar (if open) - Padding?
	// We don't have exact pane width here easily unless we pass it.
	// But usually headers aren't super long. Let's truncate to 40 chars or find a way to access width.
	// Actually, renderProjectTasks DOES pass 'width' to renderTaskByDisplayIndex but NOT to this function.
	// We should update the signature if we want perfect strictness.
	// For now, let's just be conservative.
	maxHeaderLen := 50
	if len(sectionName) > maxHeaderLen {
		sectionName = sectionName[:maxHeaderLen-1] + "‚Ä¶"
	}

	// Build the header line
	line := fmt.Sprintf("%s%s", cursor, sectionName)

	// Apply style - use TaskSelected style when cursor is here, otherwise SectionHeader
	style := styles.SectionHeader
	if isCursorHere {
		style = styles.TaskSelected
	}

	return style.Render(line)
}

// renderTaskByDisplayIndex renders a task with cursor based on display order.
func (a *App) renderTaskByDisplayIndex(taskIndex int, orderedIndices []int, width int) string {
	t := a.tasks[taskIndex]

	// Find display position for cursor
	displayPos := 0
	for i, idx := range orderedIndices {
		if idx == taskIndex {
			displayPos = i
			break
		}
	}

	// Cursor
	cursor := "  "
	if displayPos == a.taskCursor && a.focusedPane == PaneMain {
		cursor = "> "
	}

	// Selection indicator
	selectionMark := " "
	if a.selectedTaskIDs[t.ID] {
		selectionMark = "‚óè"
	}

	// Checkbox
	checkbox := styles.CheckboxUnchecked
	if t.Checked {
		checkbox = styles.CheckboxChecked
	}

	// Indent for subtasks
	indent := ""
	if t.ParentID != nil {
		indent = "  "
	}

	// Calculate metadata widths
	dueStr := ""
	dueWidth := 0
	if t.Due != nil {
		rawDue := t.DueDisplay()
		dueStr = "| " + rawDue
		dueWidth = lipgloss.Width(dueStr) + 1
	}

	labelStr := ""
	labelWidth := 0
	if len(t.Labels) > 0 {
		var lStrs []string
		for _, l := range t.Labels {
			lStrs = append(lStrs, "@"+l)
		}
		labelStr = strings.Join(lStrs, " ")
		labelWidth = lipgloss.Width(labelStr) + 1
	}

	// Calculate fixed overhead (cursor + selection + indent + checkbox + spaces)
	// "> ‚óè  [ ] " = 2 + 1 + indentLen + 4 = 7 + indentLen
	overhead := 7 + len(indent) + dueWidth + labelWidth + 2 // +2 for safety margin

	// Truncate content if needed
	content := t.Content
	maxContentWidth := width - overhead
	if maxContentWidth < 5 {
		maxContentWidth = 5
	}
	content = truncateString(content, maxContentWidth)

	// Apply priority style - use MaxWidth so Lipgloss handles color continuation if it ever wraps
	priorityStyle := styles.GetPriorityStyle(t.Priority).MaxWidth(maxContentWidth)
	styledContent := priorityStyle.Render(content)

	// Style metadata
	styledDue := ""
	if dueStr != "" {
		if t.IsOverdue() {
			styledDue = styles.TaskDueOverdue.Render(dueStr)
		} else if t.IsDueToday() {
			styledDue = styles.TaskDueToday.Render(dueStr)
		} else {
			styledDue = styles.TaskDue.Render(dueStr)
		}
	}

	styledLabels := ""
	if labelStr != "" {
		styledLabels = styles.TaskLabel.Render(labelStr)
	}

	// Build line with selection mark
	line := fmt.Sprintf("%s%s%s%s %s %s %s", cursor, selectionMark, indent, checkbox, styledContent, styledDue, styledLabels)

	// Apply base style
	style := styles.TaskItem
	if displayPos == a.taskCursor && a.focusedPane == PaneMain {
		style = styles.TaskSelected
	}
	if t.Checked {
		style = styles.TaskCompleted
	}

	// Force exactly one line and width, no wrapping
	return style.MaxWidth(width - 2).Render(line)
}

// renderScrollableLines renders lines with scrolling support using viewport.
func (a *App) renderScrollableLines(lines []lineInfo, orderedIndices []int, maxHeight int) string {
	// Store ordered indices for use in handleSelect
	a.taskOrderedIndices = orderedIndices

	if len(lines) == 0 {
		a.scrollOffset = 0
		a.viewportLines = nil
		a.viewportSections = nil
		return ""
	}

	// Build content string and track line->task mapping and section mapping
	var content strings.Builder
	a.viewportLines = make([]int, 0, len(lines))
	a.viewportSections = make([]string, 0, len(lines))

	for i, line := range lines {
		content.WriteString(line.content)
		if i < len(lines)-1 {
			content.WriteString("\n")
		}
		// Map this viewport line to its task index (-1 for headers, -2 for section headers)
		a.viewportLines = append(a.viewportLines, line.taskIndex)
		// Map this viewport line to its section ID (empty string for non-section lines)
		a.viewportSections = append(a.viewportSections, line.sectionID)
	}

	// Find which line the cursor is on
	cursorLine := 0
	if a.taskCursor >= 0 && a.taskCursor < len(orderedIndices) {
		targetTaskIndex := orderedIndices[a.taskCursor]
		for i, line := range lines {
			if line.taskIndex == targetTaskIndex {
				cursorLine = i
				break
			}
		}
	}

	// If viewport is ready, use it for scrolling
	if a.viewportReady {
		// Update viewport height if needed (maxHeight is the available height)
		if a.taskViewport.Height != maxHeight && maxHeight > 0 {
			a.taskViewport.Height = maxHeight
		}

		// Set content to viewport
		a.taskViewport.SetContent(content.String())

		// Sync viewport to show cursor
		a.syncViewportToCursor(cursorLine)

		// Store scroll offset for click handling
		a.scrollOffset = a.taskViewport.YOffset

		return a.taskViewport.View()
	}

	// Fallback: viewport not ready, just return raw content (truncated)
	a.scrollOffset = 0
	return content.String()
}

// renderTaskDetail renders the task detail view.
func (a *App) renderTaskDetail() string {
	if a.selectedTask == nil {
		return "No task selected"
	}

	t := a.selectedTask
	var b strings.Builder

	// Title with checkbox status
	checkbox := "[ ]"
	if t.Checked {
		checkbox = "[x]"
	}
	b.WriteString(styles.Title.Render("Task Details"))
	b.WriteString("\n\n")

	// Task content (main title)
	priorityStyle := styles.GetPriorityStyle(t.Priority)
	b.WriteString(fmt.Sprintf("  %s %s\n\n", checkbox, priorityStyle.Render(t.Content)))

	// Horizontal divider
	b.WriteString(styles.DetailSection.Render("  " + strings.Repeat("‚îÄ", 40)))
	b.WriteString("\n\n")

	// Description (if present)
	if t.Description != "" {
		b.WriteString(styles.DetailIcon.Render("  üìù"))
		b.WriteString(styles.DetailLabel.Render("Description"))
		b.WriteString("\n")
		b.WriteString(styles.DetailDescription.Render(t.Description))
		b.WriteString("\n\n")
	}

	// Due date
	if t.Due != nil {
		dueIcon := "üìÖ"
		dueStyle := styles.DetailValue
		if t.IsOverdue() {
			dueIcon = "üî¥"
			dueStyle = styles.TaskDueOverdue
		} else if t.IsDueToday() {
			dueIcon = "üü¢"
			dueStyle = styles.TaskDueToday
		}
		b.WriteString(styles.DetailIcon.Render("  " + dueIcon))
		b.WriteString(styles.DetailLabel.Render("Due"))
		b.WriteString(dueStyle.Render(t.Due.String))
		if t.Due.IsRecurring {
			b.WriteString(styles.HelpDesc.Render(" (recurring)"))
		}
		b.WriteString("\n")
	}

	// Priority
	priorityIcon := "‚ö™"
	priorityLabel := "P4 (Low)"
	switch t.Priority {
	case 4:
		priorityIcon = "üî¥"
		priorityLabel = "P1 (Urgent)"
	case 3:
		priorityIcon = "üü†"
		priorityLabel = "P2 (High)"
	case 2:
		priorityIcon = "üü°"
		priorityLabel = "P3 (Medium)"
	}
	b.WriteString(styles.DetailIcon.Render("  " + priorityIcon))
	b.WriteString(styles.DetailLabel.Render("Priority"))
	b.WriteString(priorityStyle.Render(priorityLabel))
	b.WriteString("\n")

	// Labels
	if len(t.Labels) > 0 {
		b.WriteString(styles.DetailIcon.Render("  üè∑Ô∏è"))
		b.WriteString(styles.DetailLabel.Render("Labels"))
		for i, l := range t.Labels {
			if i > 0 {
				b.WriteString(" ")
			}
			b.WriteString(styles.TaskLabel.Render("@" + l))
		}
		b.WriteString("\n")
	}

	// Project (find name)
	if t.ProjectID != "" {
		projectName := t.ProjectID
		for _, p := range a.projects {
			if p.ID == t.ProjectID {
				projectName = p.Name
				break
			}
		}
		b.WriteString(styles.DetailIcon.Render("  üìÅ"))
		b.WriteString(styles.DetailLabel.Render("Project"))
		b.WriteString(styles.DetailValue.Render(projectName))
		b.WriteString("\n")
	}

	// Comment count
	if t.NoteCount > 0 {
		b.WriteString(styles.DetailIcon.Render("  üí¨"))
		b.WriteString(styles.DetailLabel.Render("Comments"))
		b.WriteString(styles.DetailValue.Render(fmt.Sprintf("%d", t.NoteCount)))
		b.WriteString("\n")
	}

	// Comments section
	if len(a.comments) > 0 {
		b.WriteString("\n")
		b.WriteString(styles.DetailSection.Render("  " + strings.Repeat("‚îÄ", 40)))
		b.WriteString("\n")
		b.WriteString(styles.Subtitle.Render("  Comments"))
		b.WriteString("\n\n")

		for _, c := range a.comments {
			// Parse and format timestamp
			timestamp := c.PostedAt
			if t, err := time.Parse(time.RFC3339, c.PostedAt); err == nil {
				timestamp = t.Format("Jan 2, 2006 3:04 PM")
			}
			b.WriteString(styles.CommentAuthor.Render(fmt.Sprintf("    %s", timestamp)))
			b.WriteString("\n")
			b.WriteString(styles.CommentContent.Render(fmt.Sprintf("    %s", c.Content)))
			b.WriteString("\n\n")
		}
	}

	// Divider before help
	b.WriteString(styles.DetailSection.Render("  " + strings.Repeat("‚îÄ", 40)))
	b.WriteString("\n\n")

	// Help section
	b.WriteString(styles.HelpDesc.Render("  Shortcuts: "))
	b.WriteString(styles.HelpKey.Render("ESC"))
	b.WriteString(styles.HelpDesc.Render(" back  "))
	b.WriteString(styles.HelpKey.Render("x"))
	b.WriteString(styles.HelpDesc.Render(" complete  "))
	b.WriteString(styles.HelpKey.Render("e"))
	b.WriteString(styles.HelpDesc.Render(" edit  "))
	b.WriteString(styles.HelpKey.Render("s"))
	b.WriteString(styles.HelpDesc.Render(" add subtask"))

	return styles.Dialog.Width(a.width - 4).Render(b.String())
}

// renderTaskForm renders the add/edit task form.
func (a *App) renderTaskForm() string {
	if a.taskForm == nil {
		return styles.Dialog.Width(a.width - 4).Render("Form not initialized")
	}

	return styles.Dialog.Width(a.width - 4).Render(a.taskForm.View())
}

// renderSearch renders the search view.
func (a *App) renderSearch() string {
	var b strings.Builder

	// Title
	b.WriteString(styles.Title.Render("Search Tasks"))
	b.WriteString("\n\n")

	// Search input
	b.WriteString(styles.InputLabel.Render("Query"))
	b.WriteString("\n")
	b.WriteString(a.searchInput.View())
	b.WriteString("\n\n")

	// Results
	if a.searchQuery == "" {
		b.WriteString(styles.HelpDesc.Render("Type to search..."))
	} else if len(a.searchResults) == 0 {
		b.WriteString(styles.StatusBarError.Render("No results found"))
	} else {
		b.WriteString(styles.Subtitle.Render(fmt.Sprintf("Found %d task(s)", len(a.searchResults))))
		b.WriteString("\n\n")

		// Render search results
		for i, task := range a.searchResults {
			cursor := "  "
			itemStyle := styles.TaskItem
			if i == a.taskCursor {
				cursor = "> "
				itemStyle = styles.TaskSelected
			}

			checkbox := styles.CheckboxUnchecked
			if task.Checked {
				checkbox = styles.CheckboxChecked
			}

			content := task.Content
			priorityStyle := styles.GetPriorityStyle(task.Priority)
			content = priorityStyle.Render(content)

			// Due date
			due := ""
			if task.Due != nil {
				dueStr := task.DueDisplay()
				if task.IsOverdue() {
					due = styles.TaskDueOverdue.Render(" | " + dueStr)
				} else if task.IsDueToday() {
					due = styles.TaskDueToday.Render(" | " + dueStr)
				} else {
					due = styles.TaskDue.Render(" | " + dueStr)
				}
			}

			line := fmt.Sprintf("%s%s %s%s", cursor, checkbox, content, due)
			b.WriteString(itemStyle.Render(line))
			b.WriteString("\n")
		}
	}

	b.WriteString("\n")
	b.WriteString(styles.HelpDesc.Render("j/k: navigate | Enter: view | x: complete | Esc: back"))

	return styles.Dialog.Width(a.width - 4).Render(b.String())
}

// renderUpcoming renders the upcoming view with tasks grouped by date.
func (a *App) renderUpcoming(width, maxHeight int) string {
	var b strings.Builder

	b.WriteString(styles.Title.Render("Upcoming"))
	b.WriteString("\n")

	if a.loading {
		b.WriteString(a.spinner.View())
		b.WriteString(" Loading...")
		return b.String()
	}

	if len(a.tasks) == 0 {
		b.WriteString("\n")
		b.WriteString(styles.HelpDesc.Render("No upcoming tasks"))
		return b.String()
	}

	// Group tasks by date
	tasksByDate := make(map[string][]int)
	var dates []string

	for i, t := range a.tasks {
		if t.Due == nil {
			continue
		}
		date := t.Due.Date
		if _, exists := tasksByDate[date]; !exists {
			dates = append(dates, date)
		}
		tasksByDate[date] = append(tasksByDate[date], i)
	}

	// Sort dates
	sort.Strings(dates)

	// Build ordered indices for cursor mapping
	var orderedIndices []int
	for _, date := range dates {
		orderedIndices = append(orderedIndices, tasksByDate[date]...)
	}

	// Build lines
	var lines []lineInfo

	for idx, date := range dates {
		// Parse date for display
		displayDate := date
		if parsed, err := time.Parse("2006-01-02", date); err == nil {
			today := time.Now().Format("2006-01-02")
			tomorrow := time.Now().AddDate(0, 0, 1).Format("2006-01-02")
			switch date {
			case today:
				displayDate = "Today"
			case tomorrow:
				displayDate = "Tomorrow"
			default:
				displayDate = parsed.Format("Mon, Jan 2")
			}
		}

		// Add blank line before header (except first) for spacing
		if idx > 0 {
			lines = append(lines, lineInfo{content: "", taskIndex: -1})
		}

		lines = append(lines, lineInfo{
			content:   styles.DateGroupHeader.Render(displayDate),
			taskIndex: -1,
		})

		for _, i := range tasksByDate[date] {
			lines = append(lines, lineInfo{
				content:   a.renderTaskByDisplayIndex(i, orderedIndices, width),
				taskIndex: i,
			})
		}
	}

	// Use common scrollable rendering - maxHeight already accounts for borders
	// Subtract 2 for Title line + newline
	result := a.renderScrollableLines(lines, orderedIndices, maxHeight-2)
	b.WriteString(result)

	return b.String()
}

// renderLabelsView renders the labels view.
func (a *App) renderLabelsView(width, maxHeight int) string {
	var b strings.Builder

	b.WriteString(styles.Title.Render("Labels"))
	b.WriteString("\n\n")

	// Account for title + blank line (2 lines used)
	contentHeight := maxHeight - 2

	if a.currentLabel != nil {
		// Show tasks for selected label
		labelTitle := "@" + a.currentLabel.Name
		if a.currentLabel.Color != "" {
			labelTitle = lipgloss.NewStyle().Foreground(lipgloss.Color(a.currentLabel.Color)).Render(labelTitle)
		}
		b.WriteString(styles.Subtitle.Render(labelTitle))
		b.WriteString("\n\n")

		// Account for subtitle + blank line + footer (4 more lines)
		taskHeight := contentHeight - 4

		if len(a.tasks) == 0 {
			b.WriteString(styles.HelpDesc.Render("No tasks with this label"))
		} else {
			// Build lines and ordered indices for scrolling
			var lines []lineInfo
			var orderedIndices []int
			for i := range a.tasks {
				orderedIndices = append(orderedIndices, i)
			}
			for i := range a.tasks {
				lines = append(lines, lineInfo{
					content:   a.renderTaskByDisplayIndex(i, orderedIndices, width),
					taskIndex: i,
				})
			}
			b.WriteString(a.renderScrollableLines(lines, orderedIndices, taskHeight))
		}

		b.WriteString("\n")
		b.WriteString(styles.HelpDesc.Render("Press ESC to go back to labels list"))
	} else {
		// Extract unique labels from all tasks if personal labels are empty
		labelsToShow := a.labels
		if len(labelsToShow) == 0 {
			labelsToShow = a.extractLabelsFromTasks()
		}

		// Build task count map for labels
		taskCountMap := a.getLabelTaskCounts()

		// Account for footer (2 lines)
		labelHeight := contentHeight - 2

		// Show list of labels
		if len(labelsToShow) == 0 {
			b.WriteString(styles.HelpDesc.Render("No labels found"))
		} else {
			// Calculate scroll window for labels
			startIdx := 0
			if a.taskCursor >= labelHeight {
				startIdx = a.taskCursor - labelHeight + 1
			}
			endIdx := startIdx + labelHeight
			if endIdx > len(labelsToShow) {
				endIdx = len(labelsToShow)
			}

			for i := startIdx; i < endIdx; i++ {
				label := labelsToShow[i]
				cursor := "  "
				style := styles.LabelItem
				if i == a.taskCursor && a.focusedPane == PaneMain {
					cursor = "> "
					style = styles.LabelSelected
				}

				// Label name with optional color
				name := "@" + label.Name
				if label.Color != "" {
					name = lipgloss.NewStyle().Foreground(lipgloss.Color(label.Color)).Render(name)
				}

				// Task count badge
				taskCount := taskCountMap[label.Name]
				countBadge := ""
				if taskCount > 0 {
					countBadge = styles.HelpDesc.Render(fmt.Sprintf(" (%d)", taskCount))
				}

				line := fmt.Sprintf("%s%s%s", cursor, name, countBadge)
				b.WriteString(style.Render(line))
				b.WriteString("\n")
			}
		}

		b.WriteString("\n")
		b.WriteString(styles.HelpDesc.Render("Press Enter to view tasks with label"))
	}

	return b.String()
}

// getLabelTaskCounts returns a map of label name to task count.
func (a *App) getLabelTaskCounts() map[string]int {
	counts := make(map[string]int)

	// Use allTasks if available, otherwise fall back to tasks
	tasksToScan := a.allTasks
	if len(tasksToScan) == 0 {
		tasksToScan = a.tasks
	}

	for _, t := range tasksToScan {
		for _, labelName := range t.Labels {
			counts[labelName]++
		}
	}

	return counts
}

// extractLabelsFromTasks extracts unique labels from all tasks.
func (a *App) extractLabelsFromTasks() []api.Label {
	labelSet := make(map[string]bool)
	var labels []api.Label

	// Check allTasks first, fall back to tasks
	tasksToScan := a.allTasks
	if len(tasksToScan) == 0 {
		tasksToScan = a.tasks
	}

	for _, t := range tasksToScan {
		for _, labelName := range t.Labels {
			if !labelSet[labelName] {
				labelSet[labelName] = true
				labels = append(labels, api.Label{
					Name: labelName,
				})
			}
		}
	}

	// Sort labels alphabetically
	sort.Slice(labels, func(i, j int) bool {
		return labels[i].Name < labels[j].Name
	})

	return labels
}

// renderCalendar renders the calendar view (dispatches based on view mode).
func (a *App) renderCalendar(maxHeight int) string {
	if a.calendarViewMode == CalendarViewExpanded {
		return a.renderCalendarExpanded(maxHeight)
	}
	return a.renderCalendarCompact(maxHeight)
}

// renderCalendarCompact renders the compact calendar view.
func (a *App) renderCalendarCompact(maxHeight int) string {
	var b strings.Builder

	// Header with month/year and navigation hints
	monthYear := a.calendarDate.Format("January 2006")
	b.WriteString(styles.Title.Render(monthYear))
	b.WriteString("\n")
	b.WriteString(styles.HelpDesc.Render("‚Üê ‚Üí prev/next month | h l prev/next day | v toggle view"))
	b.WriteString("\n\n")

	// Weekday headers
	weekdays := []string{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}
	for _, wd := range weekdays {
		b.WriteString(styles.CalendarWeekday.Render(fmt.Sprintf(" %s ", wd)))
	}
	b.WriteString("\n")

	// Calculate first day and number of days in month
	firstOfMonth := time.Date(a.calendarDate.Year(), a.calendarDate.Month(), 1, 0, 0, 0, 0, time.Local)
	lastOfMonth := firstOfMonth.AddDate(0, 1, -1)
	startWeekday := int(firstOfMonth.Weekday())
	daysInMonth := lastOfMonth.Day()
	today := time.Now()

	// Build map of tasks by day
	tasksByDay := make(map[int]int) // day -> count
	for _, t := range a.allTasks {
		if t.Due == nil {
			continue
		}
		if parsed, err := time.Parse("2006-01-02", t.Due.Date); err == nil {
			if parsed.Year() == a.calendarDate.Year() && parsed.Month() == a.calendarDate.Month() {
				tasksByDay[parsed.Day()]++
			}
		}
	}

	// Render calendar grid and count weeks rendered
	day := 1
	weeksRendered := 0
	for week := 0; week < 6; week++ {
		if day > daysInMonth {
			break
		}
		weeksRendered++

		for weekday := 0; weekday < 7; weekday++ {
			if week == 0 && weekday < startWeekday {
				b.WriteString("     ")
				continue
			}

			if day > daysInMonth {
				b.WriteString("     ")
				continue
			}

			dayStr := fmt.Sprintf(" %2d ", day)
			style := styles.CalendarDay

			// Check if this is today
			isToday := today.Year() == a.calendarDate.Year() &&
				today.Month() == a.calendarDate.Month() &&
				today.Day() == day

			// Check if this day has tasks
			hasTasks := tasksByDay[day] > 0

			// Check if this is the selected day
			isSelected := day == a.calendarDay && a.focusedPane == PaneMain

			// Check if this is a weekend (Friday=5, Saturday=6 in Jordan)
			isWeekend := weekday == 5 || weekday == 6

			if isSelected {
				style = styles.CalendarDaySelected
			} else if isToday {
				style = styles.CalendarDayToday
			} else if hasTasks {
				style = styles.CalendarDayWithTasks
			} else if isWeekend {
				style = styles.CalendarDayWeekend
			}

			// Add task indicator
			if hasTasks && !isSelected {
				dayStr = fmt.Sprintf(" %2d*", day)
			}

			b.WriteString(style.Render(dayStr))
			b.WriteString(" ")
			day++
		}
		b.WriteString("\n")
	}

	// Show tasks for selected day
	b.WriteString("\n")
	selectedDate := time.Date(a.calendarDate.Year(), a.calendarDate.Month(), a.calendarDay, 0, 0, 0, 0, time.Local)
	b.WriteString(styles.Subtitle.Render(selectedDate.Format("Monday, January 2")))
	b.WriteString("\n\n")

	// Find tasks for selected day
	var dayTasks []api.Task
	selectedDateStr := selectedDate.Format("2006-01-02")
	for _, t := range a.allTasks {
		if t.Due != nil && t.Due.Date == selectedDateStr {
			dayTasks = append(dayTasks, t)
		}
	}

	// Calculate remaining height for task list
	// Used: title(1) + help(1) + blank(1) + weekdays(1) + calendar(weeksRendered) + blank(1) + subtitle(1) + blank(1)
	usedHeight := 7 + weeksRendered
	taskListHeight := maxHeight - usedHeight
	if taskListHeight < 1 {
		taskListHeight = 1
	}

	if len(dayTasks) == 0 {
		b.WriteString(styles.HelpDesc.Render("No tasks for this day"))
	} else {
		// Calculate scroll window
		startIdx := 0
		if a.taskCursor >= taskListHeight {
			startIdx = a.taskCursor - taskListHeight + 1
		}
		endIdx := startIdx + taskListHeight
		if endIdx > len(dayTasks) {
			endIdx = len(dayTasks)
		}

		for i := startIdx; i < endIdx; i++ {
			t := dayTasks[i]
			checkbox := styles.CheckboxUnchecked
			if t.Checked {
				checkbox = styles.CheckboxChecked
			}
			priorityStyle := styles.GetPriorityStyle(t.Priority)
			content := priorityStyle.Render(t.Content)

			cursor := "  "
			if i == a.taskCursor && a.focusedPane == PaneMain {
				cursor = "> "
			}
			b.WriteString(fmt.Sprintf("%s%s %s\n", cursor, checkbox, content))
		}
	}

	return b.String()
}

// renderCalendarExpanded renders the expanded calendar view with task names in cells.
func (a *App) renderCalendarExpanded(maxHeight int) string {
	var b strings.Builder

	// Header with month/year and navigation hints
	monthYear := a.calendarDate.Format("January 2006")
	b.WriteString(styles.Title.Render(monthYear))
	b.WriteString("\n")
	b.WriteString(styles.HelpDesc.Render("‚Üê ‚Üí prev/next month | h l prev/next day | v toggle view"))
	b.WriteString("\n\n")

	// Calculate cell dimensions based on terminal width
	// 7 columns + borders (8 vertical lines)
	availableWidth := a.width - 8 // Subtract for borders
	if availableWidth < 35 {
		availableWidth = 35 // Minimum width
	}
	cellWidth := availableWidth / 7
	if cellWidth < 5 {
		cellWidth = 5
	}
	if cellWidth > 20 {
		cellWidth = 20 // Max cell width
	}

	// Weekday headers
	weekdays := []string{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}
	headerLine := "‚îÇ"
	for _, wd := range weekdays {
		header := fmt.Sprintf(" %-*s", cellWidth-1, wd)
		if len(header) > cellWidth {
			header = header[:cellWidth]
		}
		headerLine += styles.CalendarWeekday.Render(header) + "‚îÇ"
	}
	b.WriteString(headerLine)
	b.WriteString("\n")

	// Top border
	topBorder := "‚îú" + strings.Repeat(strings.Repeat("‚îÄ", cellWidth)+"‚îº", 6) + strings.Repeat("‚îÄ", cellWidth) + "‚î§\n"
	b.WriteString(topBorder)

	// Calculate first day and number of days in month
	firstOfMonth := time.Date(a.calendarDate.Year(), a.calendarDate.Month(), 1, 0, 0, 0, 0, time.Local)
	lastOfMonth := firstOfMonth.AddDate(0, 1, -1)
	startWeekday := int(firstOfMonth.Weekday())
	daysInMonth := lastOfMonth.Day()
	today := time.Now()

	// Build map of tasks by day
	tasksByDay := make(map[int][]api.Task) // day -> tasks
	for _, t := range a.allTasks {
		if t.Due == nil {
			continue
		}
		if parsed, err := time.Parse("2006-01-02", t.Due.Date); err == nil {
			if parsed.Year() == a.calendarDate.Year() && parsed.Month() == a.calendarDate.Month() {
				tasksByDay[parsed.Day()] = append(tasksByDay[parsed.Day()], t)
			}
		}
	}

	// Calculate how many weeks we need to display
	weeksNeeded := (daysInMonth + startWeekday + 6) / 7

	// Calculate how many task lines to show per cell based on available height
	// Header(1) + help(1) + blank(1) + weekday(1) + topBorder(1) + statusBar(1) = 6 lines overhead
	// Each week uses: 1 (day number) + maxTasksPerCell (tasks) + 1 (separator) = 2 + maxTasksPerCell
	// Last week doesn't have separator, so: weeksNeeded * (2 + maxTasksPerCell) - 1 + 6 = maxHeight
	availableForWeeks := maxHeight - 6
	if availableForWeeks < weeksNeeded*3 {
		availableForWeeks = weeksNeeded * 3 // Minimum 1 task line per cell
	}
	// Each week row = 1 (day) + tasks + 1 (separator, except last)
	// Solve for maxTasksPerCell: weeksNeeded*(1+tasks+1) - 1 = availableForWeeks
	// weeksNeeded*(2+tasks) = availableForWeeks + 1
	// tasks = (availableForWeeks + 1) / weeksNeeded - 2
	maxTasksPerCell := (availableForWeeks+1)/weeksNeeded - 2
	if maxTasksPerCell < 2 {
		maxTasksPerCell = 2
	}
	if maxTasksPerCell > 6 {
		maxTasksPerCell = 6 // Cap at 6 tasks per cell
	}

	// Render calendar grid
	day := 1
	for week := 0; week < 6; week++ {
		if day > daysInMonth {
			break
		}

		// Row 1: Day numbers
		dayNumLine := "‚îÇ"
		for weekday := 0; weekday < 7; weekday++ {
			if week == 0 && weekday < startWeekday || day > daysInMonth {
				dayNumLine += strings.Repeat(" ", cellWidth) + "‚îÇ"
				if week == 0 && weekday < startWeekday {
					continue
				}
				continue
			}

			dayStr := fmt.Sprintf(" %2d", day)
			style := styles.CalendarDay

			isToday := today.Year() == a.calendarDate.Year() &&
				today.Month() == a.calendarDate.Month() &&
				today.Day() == day
			isSelected := day == a.calendarDay && a.focusedPane == PaneMain
			isWeekend := weekday == 5 || weekday == 6
			hasTasks := len(tasksByDay[day]) > 0

			if isSelected {
				style = styles.CalendarDaySelected
			} else if isToday {
				style = styles.CalendarDayToday
			} else if hasTasks {
				style = styles.CalendarDayWithTasks
			} else if isWeekend {
				style = styles.CalendarDayWeekend
			}

			// Pad to cell width
			paddedDay := fmt.Sprintf("%-*s", cellWidth, dayStr)
			dayNumLine += style.Render(paddedDay) + "‚îÇ"
			day++
		}
		b.WriteString(dayNumLine)
		b.WriteString("\n")

		// Reset day counter for task rows
		day -= 7
		if day < 1 {
			day = 1
		}

		// Rows 2-3: Task previews
		for taskLine := 0; taskLine < maxTasksPerCell; taskLine++ {
			taskRow := "‚îÇ"
			tempDay := day
			for weekday := 0; weekday < 7; weekday++ {
				if week == 0 && weekday < startWeekday {
					taskRow += strings.Repeat(" ", cellWidth) + "‚îÇ"
					continue
				}

				if tempDay > daysInMonth {
					taskRow += strings.Repeat(" ", cellWidth) + "‚îÇ"
					tempDay++
					continue
				}

				tasks := tasksByDay[tempDay]
				var cellContent string

				if taskLine < len(tasks) && taskLine < maxTasksPerCell-1 {
					// Show task name with priority color (truncated to fit cell)
					task := tasks[taskLine]
					taskName := task.Content
					maxLen := cellWidth - 2 // Leave space for " " prefix and margin
					if len(taskName) > maxLen && maxLen > 1 {
						taskName = taskName[:maxLen-1] + "‚Ä¶"
					}
					// Pad the plain text first, then apply priority color
					paddedTask := fmt.Sprintf(" %-*s", cellWidth-1, taskName)
					priorityStyle := styles.GetPriorityStyle(task.Priority)
					cellContent = priorityStyle.Render(paddedTask)
				} else if taskLine == maxTasksPerCell-1 && len(tasks) > maxTasksPerCell-1 {
					// Show "+N more" indicator on the last line if there are more tasks
					hiddenCount := len(tasks) - (maxTasksPerCell - 1)
					moreText := fmt.Sprintf("+%d more", hiddenCount)
					paddedMore := fmt.Sprintf(" %-*s", cellWidth-1, moreText)
					cellContent = styles.CalendarMoreTasks.Render(paddedMore)
				} else if taskLine < len(tasks) {
					// This handles the case where we're on the last allowed line but it's a task
					task := tasks[taskLine]
					taskName := task.Content
					maxLen := cellWidth - 2
					if len(taskName) > maxLen && maxLen > 1 {
						taskName = taskName[:maxLen-1] + "‚Ä¶"
					}
					paddedTask := fmt.Sprintf(" %-*s", cellWidth-1, taskName)
					priorityStyle := styles.GetPriorityStyle(task.Priority)
					cellContent = priorityStyle.Render(paddedTask)
				} else {
					// Empty cell
					cellContent = strings.Repeat(" ", cellWidth)
				}

				taskRow += cellContent + "‚îÇ"
				tempDay++
			}
			b.WriteString(taskRow)
			b.WriteString("\n")
		}

		// Move day forward after processing the week
		day += 7
		if week == 0 {
			day = 8 - startWeekday
		}

		// Row separator (except for last week)
		if day <= daysInMonth {
			separator := "‚îú" + strings.Repeat(strings.Repeat("‚îÄ", cellWidth)+"‚îº", 6) + strings.Repeat("‚îÄ", cellWidth) + "‚î§\n"
			b.WriteString(separator)
		}
	}

	// Bottom border
	bottomBorder := "‚îî" + strings.Repeat(strings.Repeat("‚îÄ", cellWidth)+"‚î¥", 6) + strings.Repeat("‚îÄ", cellWidth) + "‚îò\n"
	b.WriteString(bottomBorder)

	return b.String()
}

// renderCalendarDay renders the day detail view showing all tasks for the selected calendar day.
func (a *App) renderCalendarDay() string {
	var b strings.Builder

	// Header with date - styled nicely
	selectedDate := time.Date(a.calendarDate.Year(), a.calendarDate.Month(), a.calendarDay, 0, 0, 0, 0, time.Local)

	// Title bar
	titleStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(styles.Highlight).
		Background(lipgloss.Color("#1a1a2e")).
		Padding(0, 1).
		Width(a.width - 4)

	b.WriteString(titleStyle.Render("üìÖ " + selectedDate.Format("Monday, January 2, 2006")))
	b.WriteString("\n\n")

	if a.loading {
		b.WriteString(a.spinner.View())
		b.WriteString(" Loading tasks...")
		return b.String()
	}

	// Content area with border
	contentWidth := a.width - 4
	contentHeight := a.height - 6 // title + padding + status bar
	if contentHeight < 5 {
		contentHeight = 5
	}

	var content strings.Builder

	if len(a.tasks) == 0 {
		emptyStyle := lipgloss.NewStyle().
			Foreground(styles.Subtle).
			Italic(true).
			Align(lipgloss.Center).
			Width(contentWidth - 4)

		content.WriteString("\n")
		content.WriteString(emptyStyle.Render("No tasks scheduled for this day"))
		content.WriteString("\n\n")
		content.WriteString(emptyStyle.Render("Press 'a' to add a new task"))
	} else {
		// Task count header
		countStyle := lipgloss.NewStyle().
			Foreground(styles.Subtle)
		content.WriteString(countStyle.Render(fmt.Sprintf("%d task(s)", len(a.tasks))))
		content.WriteString("\n\n")

		// Build task lines
		taskHeight := contentHeight - 4 // account for count header and padding
		if taskHeight < 3 {
			taskHeight = 3
		}

		var lines []lineInfo
		var orderedIndices []int
		for i := range a.tasks {
			orderedIndices = append(orderedIndices, i)
			lines = append(lines, lineInfo{
				content:   a.renderTaskByDisplayIndex(i, orderedIndices, contentWidth),
				taskIndex: i,
			})
		}

		content.WriteString(a.renderScrollableLines(lines, orderedIndices, taskHeight))
	}

	// Wrap in a nice container with good padding
	containerStyle := lipgloss.NewStyle().
		BorderStyle(lipgloss.RoundedBorder()).
		BorderForeground(styles.Subtle).
		Padding(1, 3). // More vertical and horizontal padding
		MarginLeft(2).
		MarginRight(2).
		Width(contentWidth - 4) // Account for margins

	b.WriteString(containerStyle.Render(content.String()))

	return b.String()
}

// renderStatusBar renders the bottom status bar.
func (a *App) renderStatusBar() string {
	// Left side: status message or error
	left := ""
	if a.err != nil {
		left = styles.StatusBarError.Render(fmt.Sprintf("Error: %v", a.err))
	} else if a.statusMsg != "" {
		left = styles.StatusBarSuccess.Render(a.statusMsg)
	}

	// Right side: context-specific key hints (or just toggle hint if hidden)
	var right string
	if a.showHints {
		hints := a.getContextualHints()
		hints = append(hints, styles.StatusBarKey.Render("F1")+styles.StatusBarText.Render(":hide"))
		right = strings.Join(hints, " ")
	} else {
		right = styles.StatusBarKey.Render("F1") + styles.StatusBarText.Render(":keys")
	}

	// Calculate spacing
	leftWidth := lipgloss.Width(left)
	rightWidth := lipgloss.Width(right)
	padding := styles.StatusBar.GetHorizontalFrameSize()
	spacing := a.width - leftWidth - rightWidth - padding
	if spacing < 0 {
		spacing = 0
	}

	return styles.StatusBar.Width(a.width - padding).Render(left + strings.Repeat(" ", spacing) + right)
}

// getContextualHints returns context-specific key hints for the status bar.
func (a *App) getContextualHints() []string {
	key := func(k string) string { return styles.StatusBarKey.Render(k) }
	desc := func(d string) string { return styles.StatusBarText.Render(d) }

	switch a.currentTab {
	case TabToday, TabUpcoming:
		return []string{
			key("j/k") + desc(":nav"),
			key("x") + desc(":done"),
			key("e") + desc(":edit"),
			key("</>") + desc(":due"),
			key("r") + desc(":refresh"),
			key("?") + desc(":help"),
		}
	case TabLabels:
		if a.currentLabel != nil {
			return []string{
				key("j/k") + desc(":nav"),
				key("x") + desc(":done"),
				key("e") + desc(":edit"),
				key("Esc") + desc(":back"),
				key("?") + desc(":help"),
			}
		}
		return []string{
			key("j/k") + desc(":nav"),
			key("Enter") + desc(":select"),
			key("?") + desc(":help"),
			key("q") + desc(":quit"),
		}
	case TabCalendar:
		return []string{
			key("h/l") + desc(":day"),
			key("‚Üê/‚Üí") + desc(":month"),
			key("v") + desc(":view"),
			key("Enter") + desc(":select"),
			key("?") + desc(":help"),
		}
	case TabProjects:
		if a.focusedPane == PaneSidebar {
			return []string{
				key("j/k") + desc(":nav"),
				key("Enter") + desc(":select"),
				key("Tab") + desc(":pane"),
				key("?") + desc(":help"),
			}
		}
		return []string{
			key("j/k") + desc(":nav"),
			key("x") + desc(":done"),
			key("e") + desc(":edit"),
			key("Tab") + desc(":pane"),
			key("?") + desc(":help"),
		}
	default:
		return []string{
			key("j/k") + desc(":nav"),
			key("?") + desc(":help"),
			key("q") + desc(":quit"),
		}
	}
}

// updateSectionOrderCmd sends an API request to update the section order.

// reorderSectionsCmd updates the section order using the Sync API.
func (a *App) reorderSectionsCmd(sections []api.Section) tea.Cmd {
	return func() tea.Msg {
		if err := a.client.ReorderSections(sections); err != nil {
			return errMsg{err}
		}
		return reorderCompleteMsg{}
	}
}

// truncateString truncates a string to a given width and adds an ellipsis if truncated.
func truncateString(s string, width int) string {
	if lipgloss.Width(s) <= width {
		return s
	}

	// Very basic truncation that handles some ANSI/multi-byte
	// In a real app we'd use a more robust version, but this fits the immediate need.
	if width <= 1 {
		return "‚Ä¶"
	}

	// Fallback to simpler character-at-a-time width check if needed,
	// but lipgloss.Width is usually reliable for measurement.
	res := s
	for lipgloss.Width(res+"‚Ä¶") > width && len(res) > 0 {
		// Remove one character/byte at a time until it fits
		_, size := utf8.DecodeLastRuneInString(res)
		res = res[:len(res)-size]
	}
	return res + "‚Ä¶"
}
